---
# TODO: change date
date: 2023-05-30
title: Fancy Area
githubUrl: https://github.com/mxkaske/mxkaske.dev/tree/main/components/craft/fancy-area
component: FancyArea
description: A markdown textarea with mention support including hover cards in the preview. Just like GitHub.
---

<CraftWrapper>
  <FancyArea />
</CraftWrapper>

The Textarea is inspired by [GitHub](https://github.com)'s PR comment area and is powered by [shadcn/ui](https://ui.shadcn.com). Almost all elements are [radix-ui](https://www.radix-ui.com) components, styled with [tailwindcss](http://tailwindcss.com).

## UI

Let's keep it short and use [ui.shadcn](https://ui.shadcn.com).

The following components are being used:

- [Tabs](https://ui.shadcn.com/docs/components/tabs)
- [Command](https://ui.shadcn.com/docs/components/command) _(powered by [cmdk](https://github.com/pacocoursey/cmdk))_
- [Textarea](https://ui.shadcn.com/docs/components/textarea)
- [HoverCard](https://ui.shadcn.com/docs/components/hover-card)
- [Avatar](https://ui.shadcn.com/docs/components/avatar)

To style the **preview**, we use the [`@tailwindcss/typography`](https://tailwindcss.com/docs/typography-plugin) plugin including the `prose` utility class.

## A Combobox inside the Textarea

Getting the right **keyboard**, **mouse** and **touch events** and keeping the textarea focus while navigating through the mention Combobox required lots of work and testing. If you recognize an unexpected behavior, feel free to create a [GitHub Issue](https://github.com/mxkaske/mxkaske.dev/issues).

For our implementation, three utility functions have been created:

- `getCaretCoordinates()`: creates a duplicate `textarea` as `div` and return the current `{ x, y }` position of the caret _(see [textarea-caret-position](https://github.com/component/textarea-caret-position))_
- `getCurrentWord()`: returns the current word where the caret is at
- `replaceWord(value)`: replaces the word where the caret is at with the new word

Before further investigation, let's have a look at the simplified version of the `Write` Compnent:

```tsx
"use client";

import React, { useRef, useState, useEffect, useCallback } from "react";
import { Textarea } from "@/components/ui/textarea";
import { getCaretCoordinates, getCurrentWord, replaceWord } from "./utils";
import {
  Command,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import { people } from "./data";

export function Write() {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const [commandValue, setCommandValue] = useState("");
  const [textValue, setTextValue] = useState("");

  const onTextValueChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    // checks if getCurrentWord() starts with "@" and updates dropdown position based on getCaretCoordinates()
  };

  const onCommandSelect = (value: string) => {
    // replaceWord() getCurrentWord() with the `value` and hide dropdown
  };

  const handleMouseDown = (e: Event) => {
    // prevents default and stops propagating event, otherwise textarea will unfocus
  };

  const handleSectionChange = (e: Event) => {
    // detects caret position changes and adapts dropdown visiblity based on getCurrentWord()
  };

  const handleBlur = (e: Event) => {
    // hides dropdown when textarea loses focus
  };

  const handleKeyDown = (e: KeyboardEvent) => {
    // prevent default if dropdown is visible and dispatch keyboard events to input
  };

  useEffect(() => {
    textareaRef.current?.addEventListener("keydown", handleKeyDown);
    textareaRef.current?.addEventListener("blur", handleBlur);
    documentRef.current?.addEventListener(
      "selectionchange",
      handleSectionChange
    );
    dropdownRef.current?.addEventListener("mousedown", handleMouseDown);
    return () => {
      textareaRef.current?.removeEventListener("keydown", handleKeyDown);
      textareaRef.current?.removeEventListener("blur", handleBlur);
      documentRef.current?.removeEventListener(
        "selectionchange",
        handleSectionChange
      );
      dropdownRef.current?.removeEventListener("mousedown", handleMouseDown);
    };
  }, [handleBlur, handleKeyDown, handleClick, handleSectionChange]);

  return (
    <div className="relative w-full">
      <Textarea
        ref={textareaRef}
        value={textValue}
        onChange={onTextValueChange}
      />
      <Command
        ref={dropdownRef}
        className="absolute hidden h-auto max-h-32 max-w-min overflow-y-scroll"
      >
        <div className="hidden">
          {/* REMINDER: className="hidden" won't hide the SearchIcon and border-top */}
          <CommandInput ref={inputRef} value={commandValue} />
        </div>
        <CommandGroup className="max-w-min overflow-auto">
          {people.map((p) => {
            return (
              <CommandItem
                key={p.username}
                value={p.username}
                onSelect={onCommandSelect}
              >
                {p.username}
              </CommandItem>
            );
          })}
        </CommandGroup>
      </Command>
    </div>
  );
}
```

Important implementation details are:

- We hide the `Command.Input` and update the value via state updates. That way, it allows us to use the cmdk package with our custom use case under the hood.

- We propagate **keyboard events** from the textarea to the input field when dropdown is visible with: `inputRef.current?.dispatchEvent(new KeyboardEvent("keydown", e))`

- The `Textarea` listens to the caret position and the current word where the caret actually is and will be displayed whenever the `currentWord.startsWith(“@“)`.

- We didn't wrap our `Command` Component around a `Popover` or `CommandDialog` (like we did in [`Fancy Box`](https://craft.mxkaske.dev/post/fancy-box)). The Components will focus automatically and we would lose the ability to continue writing in the textarea.

- The supported `people` are statically written inside of the code (see [data.ts]()). A re-iteration of that **Fancy Area** Component could include dynamic data fetching via API resulting in using the `Command.Loading` Component.

- To replace a word, we are using the deprecated, but still heavily used and supported function:

  ```js
  document.execCommand("insertText", false, value);
  ```

  The reason for its usage: it **easily supports undo**. Please [contact me](https://twitter.com/mxkaske) if you have simple _non-deprecated_ way to do the same.

## Transform Markdown into React

The transformation is mainly handled by `rehype` plugins.

```bash
npm i unified remark-parse remark-rehype rehype-raw rehype-sanitize rehype-react
```

Let's break all the plugins down!

The following steps transform the user input into valid `react` components:

1. [`remark-parse`](https://github.com/remarkjs/remark/tree/main/packages/remark-parse): parses markdown content
2. [`remark-rehype`](<(https://github.com/remarkjs/remark-rehype)>): turns markdown into HTML and `"allowDangerousHtml"`
3. [`rehype-raw`](https://github.com/rehypejs/rehype-raw): turns raw embedded HTML into proper HTML nodes
4. [`rehype-sanitize`](https://github.com/rehypejs/rehype-sanitize): only allows safe HTML nodes
5. [`rehype-react`](https://github.com/rehypejs/rehype-react): transforms HTML into react components

```tsx
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import rehypeRaw from "rehype-raw";
import rehypeReact from "rehype-react";
import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
import { createElement, Fragment, useEffect, useState } from "react";
import { Mention } from "./mention";

export function useProcessor(md: string) {
  const [content, setContent] = useState<React.ReactNode>(null);

  // wrap words starting with '@' with custom element
  // e.g. "@jack" turns into `<mention handle="jack">@jack</mention>`
  const mentionRegex = /@(\w+)/g;
  const text = md.replace(mentionRegex, '<mention handle="$1">@$1</mention>');

  useEffect(() => {
    unified()
      .use(remarkParse)
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehypeRaw)
      .use(rehypeSanitize, {
        ...defaultSchema,
        tagNames: [...defaultSchema.tagNames!, "mention"],
        attributes: {
          ...defaultSchema.attributes,
          mention: ["handle"],
        },
      })
      // @ts-expect-error because mention is not a valid html-tag
      .use(rehypeReact, {
        createElement,
        components: {
          mention: Mention,
        },
      })
      .process(text)
      .then((file) => {
        setContent(file.result);
      });
  }, [text]);

  return content || Fragment;
}
```

We are using a Regex `/@(\w+)/g` to wrap all the words, starting with "@", inside of a custom `<mention>` element. This also means that we need to tell `rehype-sanitize` that this specific html-tag and its corresponding attribute `handle` is safe as well as extending the `rehype-react` object that maps tag names to components. In our case `{ mention: Mention }`.

We now can safely import the users content with:

```jsx
const Component = useProcessor(markdownContent);
```

## Mention HoverCard

The `Mention` Component that is being used in the preview is a _copy cat_ of shadcn example. This is also why the `Avatar` Component is being used. Period.

## Conclusion

In total, 6 files have been created:

1. `fancy-area.tsx` sticks everything together
2. `write.tsx` includes the textarea and combobox logic
3. `preview.tsx` displays the content
4. `use-processor.ts` generates jsx out of md
5. `utils.ts` includes the utility functions
6. `mention.tsx` keeps the hover card separate from the preview

The source code is available on [GitHub](https://github.com/mxkaske/mxkaske.dev/tree/main/components/craft/fancy-area).
