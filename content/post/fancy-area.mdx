---
# TODO: change date
date: 2023-05-30
title: Fancy Area
githubUrl: https://github.com/mxkaske/mxkaske.dev/tree/main/components/craft/fancy-area
component: FancyArea
description: A markdown textarea with mention support including hover cards in the preview. Just like GitHub.
---

<CraftWrapper>
  <FancyArea />
</CraftWrapper>

The Textarea is inspired by [GitHub](https://github.com)'s PR comment area and is powered by [shadcn/ui](https://ui.shadcn.com). Almost all elements are [radix-ui](https://www.radix-ui.com) components, styled with [tailwindcss](http://tailwindcss.com).

## UI

Let's keep it short and use [ui.shadcn](https://ui.shadcn.com).

The following components are being used:

- [Tabs](https://ui.shadcn.com/docs/components/tabs)
- [Command](https://ui.shadcn.com/docs/components/command) _(powered by [cmdk](https://github.com/pacocoursey/cmdk))_
- [Textarea](https://ui.shadcn.com/docs/components/textarea)
- [HoverCard](https://ui.shadcn.com/docs/components/hover-card)
- [Avatar](https://ui.shadcn.com/docs/components/avatar)

To style the **preview**, we use the [`@tailwindcss/typography`](https://tailwindcss.com/docs/typography-plugin) plugin with the `prose` utility class.

## A Combobox inside the Textarea

{/* TODO: write first what we want to acchieve */}

This was the hardest part. Getting the right **keyboard**, **mouse** and **touch events** and keeping the textarea focus while navigating through the mention Combobox required a lot of testing. If you recognize an unexpected behavior, feel free to create a [GitHub Issue](https://github.com/mxkaske/mxkaske.dev/issues).

With the help of Chat GPT and the [textarea-caret-position](https://github.com/component/textarea-caret-position) package that I have copy and pasted the function from _(We don't want to reinvent the wheel)_, the following three utility functions are being used:

- [getCaretCoordinates](): will create a duplicate `textarea` as `div` and returns the current `{ x, y }` position of the caret.
- [getCurrentWord](): will return the current word where the caret is at.
- [replaceWord](): replaces the word where the caret is at with the new word. To replace a word, we are using the deprecated, but still heavily used and supported function:

  ```js
  document.execCommand("insertText", false, value);
  ```

  To do so, we select the word to be replaced programmatically by setting the `textarea.selectionStart` and `textarea.selectionEnd` properties based on the current word and replace it with the above command with the new value.

  The reason for its usage: it **easily supports undo**. Please [contact me](https://twitter.com/mxkaske) if you have simple _non-deprecated_ way to do the same.

We hide the `Command.Input` and update the value via state updates. That way, it allows us to use the cmdk package with our custom use case under the hood.

The `Command` listens to the caret position and the current word where the caret actually is and will be displayed whenever the `currentWord.startsWith(“@“)`.

Let's have a look at the simplified version of the `write.tsx` file:

```tsx
"use client";

import React, { useRef, useState, useEffect, useCallback } from "react";
import { Textarea } from "@/components/ui/textarea";
import { getCaretCoordinates, getCurrentWord, replaceWord } from "./utils";
import {
  Command,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import { people } from "./data";

export function Write() {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const [commandValue, setCommandValue] = useState("");
  const [textValue, setTextValue] = useState("");

  const onTextValueChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      // check if current word starts with "@"
      // updates dropdown position based on caret coordinates
    },
    [setTextValue, commandValue]
  );

  const onCommandSelect = useCallback((value: string) => {
    // replace current word with new value and hide dropdown
  }, []);

  useEffect(() => {
    const textarea = textareaRef.current;
    const dropdown = dropdownRef.current;
    // support keyboard accessibility
    textarea?.addEventListener("keydown", handleKeyDown);
    // hide dropdown if open
    textarea?.addEventListener("blur", handleBlur);
    // when caret position changes, check if current word still starts with "@" otherwise hide dropdown
    document?.addEventListener("selectionchange", handleSectionChange);
    // prevent default and stop propagation as otherwise textarea would loose focus
    dropdown?.addEventListener("mousedown", handleClick);
    return () => {
      textarea?.removeEventListener("keydown", handleKeyDown);
      textarea?.removeEventListener("blur", handleBlur);
      document?.removeEventListener("selectionchange", handleSectionChange);
      dropdown?.removeEventListener("mousedown", handleClick);
    };
  }, [handleBlur, handleKeyDown, handleClick, handleSectionChange]);

  return (
    <div className="relative w-full">
      <Textarea
        ref={textareaRef}
        value={textValue}
        onChange={onTextValueChange}
      />
      <Command
        ref={dropdownRef}
        className="absolute hidden h-auto max-h-32 max-w-min overflow-y-scroll"
      >
        <div className="hidden">
          {/* REMINDER: className="hidden" won't hide the SearchIcon and border-top */}
          <CommandInput ref={inputRef} value={commandValue} />
        </div>
        <CommandGroup className="max-w-min overflow-auto">
          {people.map((p) => {
            return (
              <CommandItem
                key={p.username}
                value={p.username}
                onSelect={onCommandSelect}
              >
                {p.username}
              </CommandItem>
            );
          })}
        </CommandGroup>
      </Command>
    </div>
  );
}
```

### Additional informations

We didn't wrap our `Command` Component around a `Popover` or `CommandDialog` (like we did in [`Fancy Box`](https://craft.mxkaske.dev/post/fancy-box)) to keep being able to focus the textarea. That's why we included some extra tailwindcss utility classes to make it look similar.

The supported `people.username` are statically written inside of the code (see [data.ts]()). A reiteration of that **Fancy Area** Component could include dynamic data fetching via API resulting in using the `Command.Loading` Component.

## Mention HoverCard

The `Mention` Component that is being used in the preview is a _copy cat_ of shadcn example. This is also why the `Avatar` Component is being used. Period.

## Transform Markdown into React

The transformation is mainly handled by `rehype` plugins.

```bash
npm i unified remark-parse remark-rehype rehype-raw rehype-sanitize rehype-react
```

Let's break all the plugins down!

The following steps transform the user input into valid `react` components:

1. [`remark-parse`](https://github.com/remarkjs/remark/tree/main/packages/remark-parse): parses markdown content
2. [`remark-rehype`](<(https://github.com/remarkjs/remark-rehype)>): turns markdown into HTML and `"allowDangerousHtml"`
3. [`rehype-raw`](https://github.com/rehypejs/rehype-raw): turns raw embedded HTML into proper HTML nodes
4. [`rehype-sanitize`](https://github.com/rehypejs/rehype-sanitize): only allows safe HTML nodes
5. [`rehype-react`](https://github.com/rehypejs/rehype-react): transforms HTML into react components

```tsx
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import rehypeRaw from "rehype-raw";
import rehypeReact from "rehype-react";
import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
import { createElement, Fragment, useEffect, useState } from "react";
import { Mention } from "./mention";

export function useProcessor(md: string) {
  const [content, setContent] = useState<React.ReactNode>(null);

  // wrap words starting with '@' with custom element
  // e.g. "@jack" turns into `<mention handle="jack">@jack</mention>`
  const mentionRegex = /@(\w+)/g;
  const text = md.replace(mentionRegex, '<mention handle="$1">@$1</mention>');

  useEffect(() => {
    unified()
      .use(remarkParse)
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehypeRaw)
      .use(rehypeSanitize, {
        ...defaultSchema,
        tagNames: [...defaultSchema.tagNames!, "mention"],
        attributes: {
          ...defaultSchema.attributes,
          mention: ["handle"],
        },
      })
      // @ts-expect-error because mention is not a valid html-tag
      .use(rehypeReact, {
        createElement,
        components: {
          mention: Mention,
        },
      })
      .process(text)
      .then((file) => {
        setContent(file.result);
      });
  }, [text]);

  return content || Fragment;
}
```

Because we are using a custom `react` component to render the `HoverCard`, we will need to allow the custom `<mention>` element when sanitizing the HTML to be safe with `rehype-sanitize` as well as extending the `rehype-react` object that maps tag names to components. In our case `{ mention: Mention }`.

Check out the [`use-processor.ts`](/mxkaske.dev/components/craft/fancy-area/use-processor.ts) file.
